From 6335047a06601ba279e8a761a42794cd70461f4a Mon Sep 17 00:00:00 2001
From: Ming Huang <ming.huang@linaro.org>
Date: Wed, 13 Jun 2018 20:20:29 +0800
Subject: [PATCH edk2-platforms v2 11/43] Platform/Hisilicon/D06: Add
 M41T83RealTimeClockLib

Add M41T83RealTimeClockLib for RTC.

Contributed-under: TianoCore Contribution Agreement 1.1
Signed-off-by: Ming Huang <ming.huang@linaro.org>
---
 Platform/Hisilicon/D06/D06.dsc                                              |   1 +
 Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.inf |  46 ++
 Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClock.h      | 158 ++++++
 Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.c   | 564 ++++++++++++++++++++
 4 files changed, 769 insertions(+)

diff --git a/Platform/Hisilicon/D06/D06.dsc b/Platform/Hisilicon/D06/D06.dsc
index d14fce1159..27358f8c78 100644
--- a/Platform/Hisilicon/D06/D06.dsc
+++ b/Platform/Hisilicon/D06/D06.dsc
@@ -65,6 +65,7 @@
   CpldIoLib|Silicon/Hisilicon/Library/CpldIoLib/CpldIoLib.inf
 
   TimeBaseLib|EmbeddedPkg/Library/TimeBaseLib/TimeBaseLib.inf
+  RealTimeClockLib|Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.inf
 
   CapsuleLib|MdeModulePkg/Library/DxeCapsuleLibNull/DxeCapsuleLibNull.inf
   GenericBdsLib|IntelFrameworkModulePkg/Library/GenericBdsLib/GenericBdsLib.inf
diff --git a/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.inf b/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.inf
new file mode 100644
index 0000000000..e0bf6b3f24
--- /dev/null
+++ b/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.inf
@@ -0,0 +1,46 @@
+#/** @file
+#
+#  Copyright (c) 2018, Hisilicon Limited. All rights reserved.<BR>
+#  Copyright (c) 2018, Linaro Limited. All rights reserved.<BR>
+#
+#  This program and the accompanying materials
+#  are licensed and made available under the terms and conditions of the BSD License
+#  which accompanies this distribution.  The full text of the license may be found at
+#  http://opensource.org/licenses/bsd-license.php
+#
+#  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+#
+#**/
+
+[Defines]
+  INF_VERSION                    = 0x0001001A
+  BASE_NAME                      = M41T83RealTimeClockLib
+  FILE_GUID                      = 470DFB96-E205-4515-A75E-2E60F853E79D
+  MODULE_TYPE                    = BASE
+  VERSION_STRING                 = 1.0
+  LIBRARY_CLASS                  = RealTimeClockLib
+
+[Sources.common]
+  M41T83RealTimeClockLib.c
+
+[Packages]
+  EmbeddedPkg/EmbeddedPkg.dec
+  MdePkg/MdePkg.dec
+  Platform/Hisilicon/D06/D06.dec
+  Silicon/Hisilicon/HisiPkg.dec
+
+[LibraryClasses]
+  BaseMemoryLib
+  CpldIoLib
+  DebugLib
+  I2CLib
+  IoLib
+  PcdLib
+  TimeBaseLib
+  TimerLib
+  UefiLib
+  UefiRuntimeLib        # Use EFiAtRuntime to check stage
+
+[Depex]
+  gEfiCpuArchProtocolGuid
diff --git a/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClock.h b/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClock.h
new file mode 100644
index 0000000000..ed10099bf3
--- /dev/null
+++ b/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClock.h
@@ -0,0 +1,158 @@
+/** @file
+
+  Copyright (c) 2018, Hisilicon Limited. All rights reserved.<BR>
+  Copyright (c) 2018, Linaro Limited. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#ifndef __M41T83_REAL_TIME_CLOCK_H__
+#define __M41T83_REAL_TIME_CLOCK_H__
+
+// The delay is need for cpld and I2C. This is a empirical value. MemoryFance is no need.
+#define RTC_DELAY_30_MS            30000
+// The delay is need for cpld and I2C. This is a empirical value. MemoryFance is no need.
+#define RTC_DELAY_1000_MACROSECOND 1000
+// The delay is need for cpld and I2C. This is a empirical value. MemoryFance is no need.
+#define RTC_DELAY_2_MACROSECOND    2
+
+#define M41T83_REGADDR_DOTSECONDS       0x00
+#define M41T83_REGADDR_SECONDS          0x01
+#define M41T83_REGADDR_MINUTES          0x02
+#define M41T83_REGADDR_HOURS            0x03
+#define M41T83_REGADDR_WEEK_DAY         0x04
+#define M41T83_REGADDR_DAY              0x05
+#define M41T83_REGADDR_MONTH            0x06
+#define M41T83_REGADDR_YEAR             0x07
+#define M41T83_REGADDR_ALARM1SEC        0x0E
+#define M41T83_REGADDR_ALARM1MIN        0x0D
+#define M41T83_REGADDR_ALARM1HOUR       0x0C
+#define M41T83_REGADDR_ALARM1DATE       0x0B
+#define M41T83_REGADDR_ALARM1MONTH      0x0A
+
+#define M41T83_REGADDR_TIMERCONTROL     0x11
+
+#define M41T83_REGADDR_ALARM2SEC        0x18
+#define M41T83_REGADDR_ALARM2MIN        0x17
+#define M41T83_REGADDR_ALARM2HOUR       0x16
+#define M41T83_REGADDR_ALARM2DATE       0x15
+#define M41T83_REGADDR_ALARM2MONTH      0x14
+
+typedef union {
+  struct {
+    UINT8 TD0:1;
+    UINT8 TD1:1;
+    UINT8 RSV:3;
+    UINT8 TIE:1;
+    UINT8 TITP:1;
+    UINT8 TE:1;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_TIMERCONTROL;
+
+typedef union {
+  struct {
+    UINT8 MicroSeconds;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_DOTSECOND;
+
+typedef union {
+  struct{
+    UINT8 Seconds:7;
+    UINT8 ST:1;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_SECOND;
+
+typedef union {
+  struct {
+    UINT8 Minutes:7;
+    UINT8 Rsv:1;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_MINUTE;
+
+typedef union {
+  struct {
+    UINT8 Hours:6;
+    UINT8 CB:2;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_HOUR;
+
+typedef union {
+  struct{
+    UINT8 Days:3;
+    UINT8 Rsv:5;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_WEEK_DAY;
+
+typedef union {
+  struct{
+    UINT8 Days:6;
+    UINT8 Rsv:2;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_MONTH_DAY;
+
+typedef union {
+  struct {
+    UINT8 Months:5;
+    UINT8 Rsv:3;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_MONTH;
+
+typedef union {
+  struct {
+    UINT8 Years:8;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_YEAR;
+
+typedef union {
+  struct {
+    UINT8 Second:7;
+    UINT8 RPT11:1;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_ALARM1SEC;
+
+typedef union {
+  struct {
+    UINT8 Minute:7;
+    UINT8 RPT12:1;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_ALARM1MIN;
+
+typedef union {
+  struct {
+    UINT8 Hour:6;
+    UINT8 HT:1;
+    UINT8 RPT13:1;
+  } Bits;
+  UINT8 Uint8;
+} RTC_M41T83_ALARM1HOUR;
+
+typedef struct {
+  RTC_M41T83_DOTSECOND  DotSecond;
+  RTC_M41T83_SECOND     Second;
+  RTC_M41T83_MINUTE     Minute;
+  RTC_M41T83_HOUR       Hour;
+  RTC_M41T83_WEEK_DAY   WeekDay;
+  RTC_M41T83_MONTH_DAY  Day;
+  RTC_M41T83_MONTH      Month;
+  RTC_M41T83_YEAR       Year;
+} RTC_M41T83_TIME;
+
+#endif
diff --git a/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.c b/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.c
new file mode 100644
index 0000000000..eabe8dc0f3
--- /dev/null
+++ b/Silicon/Hisilicon/Library/M41T83RealTimeClockLib/M41T83RealTimeClockLib.c
@@ -0,0 +1,564 @@
+/** @file
+
+  Copyright (c) 2018, Hisilicon Limited. All rights reserved.<BR>
+  Copyright (c) 2018, Linaro Limited. All rights reserved.<BR>
+
+  This program and the accompanying materials
+  are licensed and made available under the terms and conditions of the BSD License
+  which accompanies this distribution.  The full text of the license may be found at
+  http://opensource.org/licenses/bsd-license.php
+
+  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
+  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
+
+**/
+
+#include <Uefi.h>
+#include <PiDxe.h>
+#include <Library/BaseLib.h>
+#include <Library/BaseMemoryLib.h>
+#include <Library/CpldD06.h>
+#include <Library/CpldIoLib.h>
+#include <Library/DebugLib.h>
+#include <Library/I2CLib.h>
+#include <Library/IoLib.h>
+#include <Library/MemoryAllocationLib.h>
+#include <Library/PcdLib.h>
+#include <Library/TimeBaseLib.h>
+#include <Library/TimerLib.h>
+#include <Library/UefiLib.h>
+#include <Library/UefiBootServicesTableLib.h>
+#include <Library/UefiRuntimeLib.h>
+#include <Library/UefiRuntimeServicesTableLib.h>
+#include <Protocol/RealTimeClock.h>
+#include "M41T83RealTimeClock.h"
+
+extern I2C_DEVICE gRtcDevice;
+
+STATIC EFI_LOCK  mRtcLock;
+
+EFI_STATUS
+SwitchRtcI2cChannelAndLock (
+  VOID
+  )
+{
+  UINT8   Temp;
+  UINT8   Count;
+
+  for (Count = 0; Count < 100; Count++) {
+    // To get the other side's state is idle first
+    Temp = ReadCpldReg (CPLD_I2C_SWITCH_FLAG);
+    if ((Temp & BIT3) != 0) {
+      (VOID) MicroSecondDelay (RTC_DELAY_30_MS);
+      // Try 100 times, if BMC has not released the bus, return preemption failed
+      if (Count == 99) {
+        if (!EfiAtRuntime ()) {
+          DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Clear cpu_i2c_rtc_state 100 times fail!\n",
+            __FUNCTION__, __LINE__));
+        }
+        return EFI_DEVICE_ERROR;
+      }
+      continue;
+    }
+
+    // if BMC free the bus, can be set 1 preemption
+    Temp = ReadCpldReg (CPLD_I2C_SWITCH_FLAG);
+    Temp = Temp | CPU_GET_I2C_CONTROL;
+    // CPU occupied RTC I2C State
+    WriteCpldReg (CPLD_I2C_SWITCH_FLAG, Temp);
+    (VOID) MicroSecondDelay (RTC_DELAY_2_MACROSECOND);
+    Temp = ReadCpldReg (CPLD_I2C_SWITCH_FLAG);
+    // Is preempt success
+    if(CPU_GET_I2C_CONTROL == (Temp & CPU_GET_I2C_CONTROL)) {
+      break;
+    }
+    if (Count == 99) {
+      if (!EfiAtRuntime ()) {
+        DEBUG((DEBUG_ERROR, "[%a]:[%dL]  Clear cpu_i2c_rtc_state fail !!! \n",
+          __FUNCTION__, __LINE__));
+      }
+      return EFI_DEVICE_ERROR;
+    }
+    (VOID) MicroSecondDelay (RTC_DELAY_30_MS);
+  }
+
+  //Polling BMC RTC I2C status
+  for (Count = 0; Count < 100; Count++) {
+    Temp = ReadCpldReg (CPLD_I2C_SWITCH_FLAG);
+    if ((Temp & BIT3) == 0) {
+      return EFI_SUCCESS;
+    }
+    (VOID) MicroSecondDelay (RTC_DELAY_30_MS);
+  }
+
+  //If the BMC occupies the RTC I2C Channel, write back the CPU side is idle
+  // or the subsequent BMC will not preempt
+  Temp = ReadCpldReg (CPLD_I2C_SWITCH_FLAG);
+  Temp = Temp & (~CPU_GET_I2C_CONTROL);
+  WriteCpldReg (CPLD_I2C_SWITCH_FLAG, Temp);
+
+  return EFI_NOT_READY;
+}
+
+
+/**
+  Read RTC content through its registers.
+
+  @param  Address   Address offset of RTC data.
+  @param  Size      Size of RTC data to read.
+  @param  Data      The data of UINT8 type read from RTC.
+
+  @return EFI_STATUS
+**/
+EFI_STATUS
+RtcRead (
+  IN  UINT8   Address,
+  IN  UINT8   Size,
+  OUT UINT8   *Data
+  )
+{
+  EFI_STATUS  Status;
+
+  Status = I2CRead (&gRtcDevice, Address, Size, Data);
+  MicroSecondDelay (RTC_DELAY_1000_MACROSECOND);
+  return Status;
+}
+
+/**
+  Write RTC through its registers.
+
+  @param  Address   Address offset of RTC data.
+  @param  Size      Size of RTC data to write.
+  @param  Data      The data of UINT8 type write from RTC.
+
+  @return EFI_STATUS
+**/
+EFI_STATUS
+RtcWrite (
+  IN  UINT8   Address,
+  IN  UINT8   Size,
+  UINT8       *Data
+  )
+{
+  EFI_STATUS  Status;
+
+  Status = I2CWrite (&gRtcDevice, Address, Size, Data);
+  MicroSecondDelay (RTC_DELAY_1000_MACROSECOND);
+  return Status;
+}
+
+VOID
+ReleaseOwnershipOfRtc (
+  VOID
+  )
+{
+  UINT8   Temp;
+
+  Temp = ReadCpldReg (CPLD_I2C_SWITCH_FLAG);
+  Temp = Temp & ~CPU_GET_I2C_CONTROL;
+  WriteCpldReg (CPLD_I2C_SWITCH_FLAG, Temp);
+}
+
+
+EFI_STATUS
+InitializeM41T83 (
+  VOID
+  )
+{
+  EFI_STATUS                Status;
+  RTC_M41T83_ALARM1HOUR     Alarm1Hour;
+  RTC_M41T83_SECOND         Second;
+
+  // Acquire RTC Lock to make access to RTC atomic
+  if (!EfiAtRuntime ()) {
+    EfiAcquireLock (&mRtcLock);
+  }
+
+  Status = I2CInit (gRtcDevice.Socket, gRtcDevice.Port, Normal);
+  MicroSecondDelay (RTC_DELAY_1000_MACROSECOND);
+  if (EFI_ERROR (Status)) {
+    if (!EfiAtRuntime ()) {
+      EfiReleaseLock (&mRtcLock);
+    }
+    return Status;
+  }
+
+  Status = SwitchRtcI2cChannelAndLock ();
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Get i2c preemption failed: %r\n", Status));
+    if (!EfiAtRuntime ()) {
+      EfiReleaseLock (&mRtcLock);
+    }
+    return Status;
+  }
+
+  MicroSecondDelay(RTC_DELAY_1000_MACROSECOND);
+
+  // Set ST at Power up to clear Oscillator fail detection(OF)
+  Status = RtcRead (M41T83_REGADDR_SECONDS, 1, &Second.Uint8);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+      __FUNCTION__, __LINE__, Status));
+  }
+  Second.Bits.ST= 1;
+  Status = RtcWrite (M41T83_REGADDR_SECONDS, 1, &Second.Uint8);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+      __FUNCTION__, __LINE__, Status));
+    goto Exit;
+  }
+  Status = RtcRead (M41T83_REGADDR_SECONDS, 1, &Second.Uint8);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+      __FUNCTION__, __LINE__, Status));
+  }
+  Second.Bits.ST= 0;
+  Status = RtcWrite (M41T83_REGADDR_SECONDS, 1, &Second.Uint8);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+      __FUNCTION__, __LINE__, Status));
+    goto Exit;
+  }
+
+  // Clear HT bit to enanle write to the RTC registers (addresses 0-7)
+  Status = RtcRead (M41T83_REGADDR_ALARM1HOUR, 1, &Alarm1Hour.Uint8);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+      __FUNCTION__, __LINE__, Status));
+  }
+  Alarm1Hour.Bits.HT = 0;
+  Status = RtcWrite (M41T83_REGADDR_ALARM1HOUR, 1, &Alarm1Hour.Uint8);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+      __FUNCTION__, __LINE__, Status));
+    goto Exit;
+  }
+
+Exit:
+  // Release RTC Lock.
+  ReleaseOwnershipOfRtc ();
+  if (!EfiAtRuntime ()) {
+    EfiReleaseLock (&mRtcLock);
+  }
+  return Status;
+}
+
+/**
+  Sets the current local time and date information.
+
+  @param  Time                  A pointer to the current time.
+
+  @retval EFI_SUCCESS           The operation completed successfully.
+  @retval EFI_INVALID_PARAMETER A time field is out of range.
+  @retval EFI_DEVICE_ERROR      The time could not be set due due to hardware error.
+
+**/
+EFI_STATUS
+EFIAPI
+LibSetTime (
+  IN  EFI_TIME                *Time
+  )
+{
+  EFI_STATUS                  Status = EFI_SUCCESS;
+  RTC_M41T83_TIME             BcdTime;
+  UINT16                      CenturyBase = 2000;
+  UINTN                       LineNum = 0;
+
+  if (NULL == Time) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!IsTimeValid (Time)) {
+    if (!EfiAtRuntime ()) {
+      DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+        __FUNCTION__, __LINE__, Status));
+      DEBUG ((DEBUG_ERROR, "Now RTC Time is : %04d-%02d-%02d %02d:%02d:%02d\n",
+        Time->Year, Time->Month, Time->Day, Time->Hour, Time->Minute, Time->Second
+      ));
+    }
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Status = SwitchRtcI2cChannelAndLock ();
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+  (VOID)MicroSecondDelay (RTC_DELAY_1000_MACROSECOND);
+
+  SetMem (&BcdTime, sizeof (RTC_M41T83_TIME), 0);
+
+  // Acquire RTC Lock to make access to RTC atomic
+  if (!EfiAtRuntime ()) {
+    EfiAcquireLock (&mRtcLock);
+  }
+
+  BcdTime.Second.Bits.Seconds = DecimalToBcd8 (Time->Second);
+  BcdTime.Minute.Bits.Minutes = DecimalToBcd8 (Time->Minute);
+  BcdTime.Hour.Bits.Hours = DecimalToBcd8 (Time->Hour);
+  BcdTime.Day.Bits.Days = DecimalToBcd8 (Time->Day);
+  BcdTime.Month.Bits.Months = DecimalToBcd8 (Time->Month);
+  BcdTime.Year.Bits.Years = DecimalToBcd8 (Time->Year % 100);
+  BcdTime.Hour.Bits.CB = (Time->Year - CenturyBase) / 100 % 10;
+
+  Status = RtcWrite (M41T83_REGADDR_DOTSECONDS, 1, &BcdTime.DotSecond.Uint8);
+  if (EFI_ERROR (Status)) {
+    LineNum = __LINE__;
+    goto Exit;
+  }
+  Status = RtcWrite (M41T83_REGADDR_SECONDS, 1, &BcdTime.Second.Uint8);
+  if (EFI_ERROR (Status)) {
+    LineNum = __LINE__;
+    goto Exit;
+  }
+  Status = RtcWrite (M41T83_REGADDR_MINUTES, 1, &BcdTime.Minute.Uint8);
+  if (EFI_ERROR (Status)) {
+    LineNum = __LINE__;
+    goto Exit;
+  }
+  Status = RtcWrite (M41T83_REGADDR_HOURS, 1, &BcdTime.Hour.Uint8);
+  if (EFI_ERROR (Status)) {
+    LineNum = __LINE__;
+    goto Exit;
+  }
+  Status = RtcWrite (M41T83_REGADDR_DAY, 1, &BcdTime.Day.Uint8);
+  if (EFI_ERROR (Status)) {
+    LineNum = __LINE__;
+    goto Exit;
+  }
+  Status = RtcWrite (M41T83_REGADDR_MONTH, 1, &BcdTime.Month.Uint8);
+  if (EFI_ERROR (Status)) {
+    LineNum = __LINE__;
+    goto Exit;
+  }
+  Status = RtcWrite (M41T83_REGADDR_YEAR, 1, &BcdTime.Year.Uint8);
+  if (EFI_ERROR (Status)) {
+    LineNum = __LINE__;
+    goto Exit;
+  }
+
+Exit:
+  ReleaseOwnershipOfRtc ();
+  // Release RTC Lock.
+  if (!EfiAtRuntime ()) {
+    if (EFI_ERROR (Status)) {
+      DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+        __FUNCTION__, LineNum, Status));
+    }
+    EfiReleaseLock (&mRtcLock);
+  }
+  return Status;
+}
+
+
+/**
+  Returns the current time and date information, and the time-keeping capabilities
+  of the hardware platform.
+
+  @param  Time                   A pointer to storage to receive a snapshot of the current time.
+  @param  Capabilities           An optional pointer to a buffer to receive the real time clock
+                                 device's capabilities.
+
+  @retval EFI_SUCCESS            The operation completed successfully.
+  @retval EFI_INVALID_PARAMETER  Time is NULL.
+  @retval EFI_DEVICE_ERROR       The time could not be retrieved due to hardware error.
+  @retval EFI_SECURITY_VIOLATION The time could not be retrieved due to an authentication failure.
+**/
+EFI_STATUS
+EFIAPI
+LibGetTime (
+  OUT EFI_TIME                *Time,
+  OUT EFI_TIME_CAPABILITIES   *Capabilities
+  )
+{
+  EFI_STATUS                  Status = EFI_SUCCESS;
+  RTC_M41T83_TIME             BcdTime;
+  UINT16                      CenturyBase = 2000;
+  UINTN                       LineNum = 0;
+  BOOLEAN                     IsTimeInvalid = FALSE;
+  UINT8                       TimeTemp[7] = {0};
+
+  // Ensure Time is a valid pointer
+  if (Time == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  Status = SwitchRtcI2cChannelAndLock ();
+  if (EFI_ERROR (Status)) {
+    return Status;
+  }
+
+  MicroSecondDelay(RTC_DELAY_1000_MACROSECOND);
+
+  SetMem (&BcdTime, sizeof (RTC_M41T83_TIME), 0);
+  SetMem (Time , sizeof (EFI_TIME), 0);
+
+  // Acquire RTC Lock to make access to RTC atomic
+  if (!EfiAtRuntime ()) {
+    EfiAcquireLock (&mRtcLock);
+  }
+
+  Status = RtcRead (M41T83_REGADDR_SECONDS, 7, TimeTemp);
+  if (EFI_ERROR (Status)) {
+    LineNum = __LINE__;
+    goto Exit;
+  }
+
+  BcdTime.Second.Uint8 = TimeTemp[0];  //SECONDS
+  BcdTime.Minute.Uint8 = TimeTemp[1];  //MINUTES
+  BcdTime.Hour.Uint8 = TimeTemp[2];    //HOURS
+  BcdTime.Day.Uint8 = TimeTemp[4];     //DAY
+  BcdTime.Month.Uint8 = TimeTemp[5];   //MONTH
+  BcdTime.Year.Uint8 = TimeTemp[6];    //Year
+
+  Time->Year = BcdToDecimal8 (BcdTime.Year.Bits.Years);
+  Time->Year += CenturyBase + BcdTime.Hour.Bits.CB * 100;
+  Time->Month = BcdToDecimal8 (BcdTime.Month.Bits.Months);
+  Time->Day = BcdToDecimal8 (BcdTime.Day.Bits.Days);
+  Time->Hour = BcdToDecimal8 (BcdTime.Hour.Bits.Hours);
+  Time->Minute = BcdToDecimal8 (BcdTime.Minute.Bits.Minutes);
+  Time->Second = BcdToDecimal8 (BcdTime.Second.Bits.Seconds);
+  Time->TimeZone = EFI_UNSPECIFIED_TIMEZONE;
+
+  if (!IsTimeValid (Time)) {
+      Status = EFI_DEVICE_ERROR;
+      LineNum = __LINE__;
+      IsTimeInvalid = TRUE;
+      goto Exit;
+  }
+
+Exit:
+  ReleaseOwnershipOfRtc ();
+  // Release RTC Lock.
+  if (!EfiAtRuntime ()) {
+    if (EFI_ERROR (Status)) {
+      if (IsTimeInvalid == TRUE) {
+        DEBUG((DEBUG_ERROR, "%a(%d) Time invalid.\r\n",__FUNCTION__, LineNum));
+      } else {
+        DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\n",
+          __FUNCTION__, LineNum, Status));
+      }
+    }
+    EfiReleaseLock (&mRtcLock);
+  }
+  return Status;
+}
+
+
+/**
+  Returns the current wakeup alarm clock setting.
+
+  @param  Enabled               Indicates if the alarm is currently enabled or disabled.
+  @param  Pending               Indicates if the alarm signal is pending and requires acknowledgement.
+  @param  Time                  The current alarm setting.
+
+  @retval EFI_SUCCESS           The alarm settings were returned.
+  @retval EFI_INVALID_PARAMETER Any parameter is NULL.
+  @retval EFI_DEVICE_ERROR      The wakeup time could not be retrieved due to a hardware error.
+
+**/
+EFI_STATUS
+EFIAPI
+LibGetWakeupTime (
+  OUT BOOLEAN     *Enabled,
+  OUT BOOLEAN     *Pending,
+  OUT EFI_TIME    *Time
+  )
+{
+  // Not a required feature
+  return EFI_UNSUPPORTED;
+}
+
+
+/**
+  Sets the system wakeup alarm clock time.
+
+  @param  Enabled               Enable or disable the wakeup alarm.
+  @param  Time                  If Enable is TRUE, the time to set the wakeup alarm for.
+
+  @retval EFI_SUCCESS           If Enable is TRUE, then the wakeup alarm was enabled. If
+                                Enable is FALSE, then the wakeup alarm was disabled.
+  @retval EFI_INVALID_PARAMETER A time field is out of range.
+  @retval EFI_DEVICE_ERROR      The wakeup time could not be set due to a hardware error.
+  @retval EFI_UNSUPPORTED       A wakeup timer is not supported on this platform.
+
+**/
+EFI_STATUS
+EFIAPI
+LibSetWakeupTime (
+  IN  BOOLEAN      Enabled,
+  OUT EFI_TIME     *Time
+  )
+{
+  // Not a required feature
+  return EFI_UNSUPPORTED;
+}
+
+
+/**
+  This is the declaration of an EFI image entry point. This can be the entry point to an application
+  written to this specification, an EFI boot service driver, or an EFI runtime driver.
+
+  @param  ImageHandle           Handle that identifies the loaded image.
+  @param  SystemTable           System Table for this image.
+
+  @retval EFI_SUCCESS           The operation completed successfully.
+
+**/
+EFI_STATUS
+EFIAPI
+LibRtcInitialize (
+  IN EFI_HANDLE                            ImageHandle,
+  IN EFI_SYSTEM_TABLE                      *SystemTable
+  )
+{
+  EFI_STATUS    Status = EFI_SUCCESS;
+  EFI_TIME      EfiTime;
+
+  EfiInitializeLock (&mRtcLock, TPL_CALLBACK);
+
+  // Setup the setters and getters
+  gRT->GetTime       = LibGetTime;
+  gRT->SetTime       = LibSetTime;
+  gRT->GetWakeupTime = LibGetWakeupTime;
+  gRT->SetWakeupTime = LibSetWakeupTime;
+
+  Status = InitializeM41T83 ();
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "[%a]:[%dL] Status : %r\nRTC M41T83 Init Failed !!!\n",
+            __FUNCTION__, __LINE__, Status));
+    /*
+     * Returning ERROR on failure of RTC initilization will cause the system to hang up.
+     * So we add some debug message to indecate the RTC initilization failed,
+     * and continue without returning with error to avoid system hanging up.
+     *
+     *return Status;
+     */
+  }
+
+  LibGetTime (&EfiTime, NULL);
+  if (!IsTimeValid (&EfiTime)) {
+    EfiTime.Year    = 2015;
+    EfiTime.Month   = 1;
+    EfiTime.Day     = 1;
+    EfiTime.Hour    = 0;
+    EfiTime.Minute  = 0;
+    EfiTime.Second  = 0;
+    Status = LibSetTime (&EfiTime);
+    if (EFI_ERROR (Status)) {
+      DEBUG ((DEBUG_ERROR, "[%a]:[%dL] RTC settime Status : %r\n",
+        __FUNCTION__, __LINE__, Status));
+    }
+  }
+
+  DEBUG ((
+    DEBUG_ERROR, "Now RTC Time is : %04d-%02d-%02d %02d:%02d:%02d\n",
+    EfiTime.Year, EfiTime.Month, EfiTime.Day, EfiTime.Hour, EfiTime.Minute,
+    EfiTime.Second
+    ));
+    /*
+     * Returning ERROR on failure of RTC initilization will cause the system to hang up.
+     * So we add some debug message to indecate the RTC initilization failed,
+     * and return success to avoid system hanging up.
+     */
+  return EFI_SUCCESS;
+}
-- 
2.17.0

